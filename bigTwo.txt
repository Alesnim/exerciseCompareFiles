Центральным элементом системы ввода/вывода является поток (stream). Это сущность, описывающая возможность получения данных из какого-либо источника (например, файла), либо записи в какой-либо источник. В Java это наследники абстрактных классов InputStream/OutputStream. Например, это классы FileInputStream/FileOutputStream. Их можно использовать для побайтного чтения/записи в файлы. Ниже приведен фрагмент кода — классический пример побайтного копирования файла:


in = new FileInputStream("a.txt");
out = new FileOutputStream("b.txt");
int c;
while ((c = in.read()) != -1) {
    out.write(c);
}
Конечно, следует обеспечить обработку потенциальных исключительных ситуаций, например, при помощи блока try-catch, а также закрыть в конце потоки методом close().

Однако обычно побайтно считывать информацию неудобно, поэтому существует множество дополнительных классов. Можно использовать более высокоуровневые классы — например, PrintStream. Ярким примером потоков является стандартные потоки System.in (типа InputStream), System.out (типа PrintStream), System.err (типа PrintStream), которые всегда существуют как объекты в работающей java-программе и обычно используются для вывода сообщений в консоль:


System.out.println("Это сообщение в консоль");
Класс PrintWriter
Еще один высокоуровневый класс PrintWriter очень близок к стандартным возможностям языка C. При создании объекта этого класса входным параметром для него служит уже открытый поток. Методы print(), println() и printf() определены для всех стандартных типов и очень похожи на соответствующие процедуры языка C. Например, ниже приведен фрагмент кода, позволяющий записать в файл FF (шестнадцатеричное представление 255):


try {
    File file = new File("d:/testfiles.txt");
    PrintWriter writer = new PrintWriter(new FileWriter(file));
    writer.printf("%x", 255); //Записываем текст в файл
    writer.close(); // Закрываем файл
} catch (IOException e) {
    e.printStackTrace();
}
В этом примере создается объект файла с именем testfiles.txt (но не сам файл), затем создается поток FileWriter (в это момент файл реально создастся), и, наконец, он оборачивается в объект PrintWriter. Обратите особое внимание на то, что после записи каких-либо данных в файл его необходимо закрыть, только после этого данные действительно запишутся в файл.

Класс Scanner
Начиная с версии 1.5, в Java появился класс Scanner в пакете java.util. При создании объекта ему в качестве аргумента могут передаваться файл или поток для считывания. Далее для каждого из базовых типов <Т> имеется пара методов:

hasNext() проверяет можно ли далее прочесть данные типа T;
next() для считывания данных этого типа.
Например, метод nextInt() считывает очередной int, а метод hasNextDouble() возвращает истину или ложь в зависимости от того, есть ли в потоке следующее значение double для чтения. Например, чтение строк файла a.txt и вывод их в консоль построчно:


try {
    File file = new File("d:/a.txt");
    Scanner scanner = new Scanner(file);
    while (scanner.hasNext()) {
          System.out.println(scanner.next());
    }
    scanner.close();
} catch (FileNotFoundException e) {
    e.printStackTrace();
}
Хотя Scanner и не является потоком, у него тоже необходимо вызывать метод close(), который закроет используемый за основной источник поток.


Несмотря на то что обычно при завершении программы на Java, открытые файлы закрываются автоматически, все же рекомендуется обеспечить корректное закрытие потоков даже при возможном возникновении исключений. Для этого удобнее всего метод close() включать в блок finally.

Пример 3.2
В рассматриваемом примере необходимо написать функцию, которая принимает строки с именами файлов, исходного и целевого. Необходимо скопировать содержимое исходного текстового файла в выходной с заменой слова «School» на слово «Школа». Например, файл in.txt:

IT School SAMSUNG – программа дополнительного образования по основам IT и программирования. Она создана компанией Samsung с целью обучить 5 000 школьников в более чем 20 городах России в течение 5 лет.
то выходной файл out.txt:

IT Школа SAMSUNG – программа дополнительного образования по основам IT и программирования. Она создана компанией Samsung c целью обучить 5 000 школьников в более чем 20 городах России в течение 5 лет.
Для решения поставленной задачи в создаваемом методе, назовем его replace, воспользуемся низкоуровневыми инструментами Scanner и PriontWriter:


void replace(String fileIn,String fileOut) {
    File in=new File(fileIn);
    File out=new File(fileOut);
    Scanner sc=new Scanner(in);
    PrintWriter pw=new PrintWriter(out);
        // код копирования будет здесь
}
Далее в цикле будем пословно считывать исходный файл и писать в целевой, с заменой слова, конечно. Ниже приведен код копирования:


sc.close();
pw.close();
При работе с файлами часто имеются критические блоки кода, требующие обработки исключений. В имеющейся постановке задачи недостаточно данных для качественной обработки, поэтому принимаем решение делегировать обработку вышестоящему контексту, добавив в описание функции ключевого слова throws и типа делегируемого исключения. В итоге функция имеет следующий вид:


void replace(String fileIn,String fileOut) throws FileNotFoundException{
    File in=new File(fileIn);
    File out=new File(fileOut);
    Scanner sc=new Scanner(in);
    PrintWriter pw=new PrintWriter(out);
    while(sc.hasNext()){
        String word=sc.next();
        if(word.equals("School"))
                      word="Школа";
        pw.print(word+" ");
    }
    sc.close();
    pw.close();
}
Протестировать использование функции replace можно следующим образом:


public static void main(String[] args) {
    FileIO test=new FileIO();
    try{
     test.replace("in.txt", "out.txt");
    }catch(Exception ex){
        System.out.println("Что то пошло не так: "+ex.getMessage());
    }
}